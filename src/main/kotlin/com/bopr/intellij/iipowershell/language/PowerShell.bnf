/**
* PowerShell grammar.
*
* @see grammar reference: https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-15?view=powershell-7.3
*
* @author Boris Pronin
*/

{
    generate = [
        psi = 'no'
//        exact-types = 'elements'
//        java = '8'
    ]

    elementTypeClass="com.bopr.intellij.iipowershell.language.psi.PowerShellElementType"
    elementTypeHolderClass="com.bopr.intellij.iipowershell.language.psi.PowerShellTypes"
    extends="com.bopr.intellij.iipowershell.language.psi.PowerShellPsiElement"
    parserClass="com.bopr.intellij.iipowershell.parser.PowerShellParser"
//    psiClassPrefix="PowerShell"
    psiImplClassSuffix="Impl"
    psiImplPackage="com.bopr.intellij.iipowershell.language.psi.impl"
    psiImplUtilClass="com.bopr.intellij.iipowershell.language.psi.PowerShellPsiUtil"
    psiPackage="com.bopr.intellij.iipowershell.psi"
    tokenTypeClass="com.bopr.intellij.iipowershell.language.psi.PowerShellTokenType"

    tokens = [
        NEW_LINE = 'regexp:[\r\n]'
        WHITE_SPACE = 'regexp:\s+'
        LINE_COMMENT = 'regexp:#.*'
        REQUIRES_COMMENT = 'regexp:#\s*requires\s+.*'
        BLOCK_COMMENT = 'regexp:<#(.|\n)*#>'
        SIGNATURE = 'regexp:# SIG # Begin signature block\n(#(.|\n)*)+# SIG # End signature block'

        DECIMAL_INTEGER_NUMBER = 'regexp:[+-]?\d+[ld]?([kmgtp]b)?'
        HEXADECIMAL_INTEGER_NUMBER = 'regexp:[+-]?0x[0-9da-f]+[ld]?([kmgtp]b)?'
        REAL_NUMBER = 'regexp:[+-]?\d*\.\d+(e\d+[ld]?([kmgtp]b)?)?'
        STRING = 'regexp:"([^$`"]|"")*\$?"'

        KEYWORD = 'regexp:(begin|break|catch|class|continue|data|define|do|dynamicparam|elseif|else|end|exit|filter|finally|foreach|for|from|function|if|in|inlinescript|parallel|param|process|return|switch|throw|trap|try|until|using|var|while|workflow)'
        DEFAULT_CLAUSE = 'default'

        REGULAR_VARIABLE = 'regexp:[$@][\w_?:]+'
        BRACED_VARIABLE = 'regexp:\$\{[^}]+[^`]}'

        LABEL = 'regexp::\w+'

        ASSIGNMENT_OPERATOR = 'regexp:[+*/%-]?='
        FILE_REDIRECTION_OPERATOR = 'regexp:[><]|(>>)|(2>)|(2>>)|(3>)|(3>>)|(4>)|(4>>)|(5>)|(5>>)|(6>)|(6>>)|(\*>)|(\*>>)'
        MERGING_REDIRECTION_OPERATOR = 'regexp:(\*>&1)|(2>&1)|(3>&1)|(4>&1)|(5>&1)|(6>&1)|(\*>&2)|(1>&2)|(3>&2)|(4>&2)|(5>&2)|(6>&2)'
        FORMAT_OPERATOR = 'regexp:-f'
        COMPARISON_OPERATOR = 'regexp:-[ic]?(eq|ne|gt|lt|le|ge|match|notmatch|replace|like|notlike|contains|notcontains|split|join)'
        LOGICAL_OPERATOR = 'regexp:-and|or|xor'
        BITWISE_LOGICAL_OPERATOR = 'regexp:-band|bor|bxor'
        LOGICAL_NOT_OPERATOR = '-not'
        BITWISE_LOGICAL_NOT_OPERATOR = '-bnot'
        SPLIT_OPERATOR = '-split'
        JOIN_OPERATOR = '-join'

        FILE_PARAMETER = '-file'
        SUPPORTED_COMMAND_PARAMETER = '-supportedcommand'
        SWITCH_PARAMETER = 'regexp:-regex|wildcard|exact|casesensitive|parallel'

        VERBATIM_COMMAND_ARGUMENT = '--%.*'
        INCREMENT_OPERATOR = '++'
        DECREMENT_OPERATOR = '--'
        SYMBOLIC_OPERATOR = 'regexp:(\.\.)|(::)|(&&)|(\|\|)|[!&|\-+*/%]'
        DASH = '-'
        SEMICOLON = ';'
        DOT = '.'
        COMMA = ','
        DOUBLE_QUOTE = '"'
        BRACED_VARIABLE_START = '${'
        SUB_EXPRESSION_START = '$('
        HASH_EXPRESSION_START = '@{'
        ARRAY_EXPRESSION_START = '@('
        MULTILINE_STRING_START = '@"'
        MULTILINE_STRING_END = '"@'
        VERBATIM_MULTILINE_STRING_START = "@'"
        VERBATIM_MULTILINE_STRING_END = "'@"
        LBRACE = '{'
        RBRACE = '}'
        LBRACKET = '['
        RBRACKET = ']'
        LPARENTHESIS = '('
        RPARENTHESIS = ')'

//        COMMAND_PARAMETER = 'regexp:-\w+[?\w]+;?'
//        TYPE_IDENTIFIER = 'regexp:[\p{Alpha}_]\w*'
        SIMPLE_IDENTIFIER = 'regexp:[\p{Alpha}_]\w*'
//        GENERIC_IDENTIFIER = "regexp:\w+[-?\w]+"
        COMMAND_PARAMETER = 'regexp:[\p{Alpha}_?]\w*:?'
//        GENERIC_TOKEN_WITH_SUBEXPR_START = "regexp:\w+[-?\w]+\$\("
//        ARRAY_TYPE_NAME = 'regexp:\[\w+[-?\w]+]\['
//        GENERIC_TYPE_NAME = 'regexp:\[\w+[-?\w]+]\['



        /* Dummy items to generate corresponding tags */
//        ATTRIBUTE_IDENTIFIER = '<attribute>'
//        TYPE_IDENTIFIER = '<type>'
        COMMAND_IDENTIFIER = '<command>'
        ARGUMENT = '<argument>'
    ]
    
    name('.*expression') = 'expression'
    name('.*statement') = 'statement'
    name('.*operator') = 'operator'
}

root ::=
//  "regexp:.*"
     script-file
//  | module-file
//  | interactive-input
//  | data-file

/* B.1.3 White space */

whitespace ::=
    'regexp:([\p{Zs}\p{Zl}\p{Zp}\u0009\u000B\u000C]|`[\r\n])+'
/*
    Any character with Unicode class Zs, Zl, or Zp
    Horizontal tab character (U+0009)
    Vertical tab character (U+000B)
    Form feed character (U+000C)
    ` (The backtick character U+0060) followed by new-line-character
*/

private nl ::=
    NEW_LINE *

private no-space ::=
    "" //todo:

private comparison-operator ::=
    COMPARISON_OPERATOR

private format-operator ::=
    FORMAT_OPERATOR

private assignment-operator ::=
    ASSIGNMENT_OPERATOR

private file-redirection-operator ::=
    FILE_REDIRECTION_OPERATOR

private merging-redirection-operator ::=
    MERGING_REDIRECTION_OPERATOR

private increment-operator ::=
    INCREMENT_OPERATOR

private decrement-operator ::=
    DECREMENT_OPERATOR

private additive-operator ::=
    '+' | DASH

private multiplicative-operator ::=
    '\*' | '/' | '%'

private logical-operator ::=
    LOGICAL_OPERATOR

private bitwise-logical-operator ::=
    BITWISE_LOGICAL_OPERATOR

private logical-not-operator ::=
    LOGICAL_NOT_OPERATOR

private bitwise-logical-not-operator ::=
    BITWISE_LOGICAL_NOT_OPERATOR

private split-operator ::=
    SPLIT_OPERATOR

private join-operator ::=
    JOIN_OPERATOR

private range-operator ::=
    '..'

private array-literal-operator ::=
    COMMA

variable ::=
    REGULAR_VARIABLE
  | braced-variable

private braced-variable ::=
    BRACED_VARIABLE
//  | escaped-character

//escaped-character ::=
//    '`'   //(The backtick character U+0060) followed by any Unicode character

/* B.1.7 Commands */

generic-token ::=
    generic-token-parts

private generic-token-parts ::=
    generic-token-part+

private generic-token-part ::=
    expandable-string-literal
  | verbatim-here-string-literal
  | variable
  | generic-token-char

private generic-token-char ::=
    SIMPLE_IDENTIFIER
//    GENERIC_IDENTIFIER
/*
    Any Unicode character except
        {   }   (   )   ;   ,   |   &   $
        ` (The backtick character U+0060)
        double-quote-character
        single-quote-character
        whitespace
        new-line-character
        escaped-character
*/

generic-token-with-subexpr-start ::=
    generic-token-parts '$('

/* B.1.8 Parameters*/

private command-parameter ::=
//    dash first-parameter-char parameter-chars colon~opt~
    COMMAND_PARAMETER

/*
first-parameter-char:
    A Unicode character of classes Lu, Ll, Lt, Lm, or Lo
    _ (The underscore character U+005F)
    ?
parameter-char:
    Any Unicode character except
        { } ( ) ; , | & . [
        colon
        whitespace
        new-line-character
colon:
    : (The colon character U+003A)
*/


//verbatim-command-argument-chars ::=
//     verbatim-command-argument-part+
//
//verbatim-command-argument-part ::=
//     verbatim-command-string
//     | '&' non-ampersand-character
//     | non-vert-line-character
//
//non-ampersand-character ::=
//    !'&'
//
//non-vert-line-character ::=
//    !'|'
//
//verbatim-command-string ::=
//     double-quote-character non-double-quote-chars
//   | double-quote-character
//
//non-double-quote-chars ::=
////todo: DOES NOT WORK
//    (!double-quote-character)+

/* B.1.9 Literals */

private literal ::=
    integer-literal
  | real-literal
  | string-literal

/* B.1.9.1 Integer Literals */

integer-literal ::=
    DECIMAL_INTEGER_NUMBER | HEXADECIMAL_INTEGER_NUMBER

/* B.1.9.2 Real Literals */

real-literal ::=
    REAL_NUMBER

/* B.1.9.3 String Literals */

string-literal ::=
    expandable-string-literal
  | expandable-here-string-literal
  | verbatim-string-literal
  | verbatim-here-string-literal

expandable-string-literal ::=
    STRING
//    DOUBLE_QUOTE expandable-string-characters? '$'* DOUBLE_QUOTE

expandable-string-characters ::=
    expandable-string-part+

expandable-string-part ::=
    !('$' | DOUBLE_QUOTE | '`')
  | braced-variable
//  | '$' !('(' |'{' | DOUBLE_QUOTE | '`')
//  | '$' escaped-character
//  | escaped-character
//  | DOUBLE_QUOTE DOUBLE_QUOTE

/*
    Any Unicode character except
        $
        double-quote-character
        ` (The backtick character U+0060)
    braced-variable
    $ Any Unicode character except
        (
        {
        double-quote-character
        ` (The backtick character U+0060)*
    $ escaped-character
    escaped-character
    double-quote-character double-quote-character
*/

expandable-here-string-literal ::=
    MULTILINE_STRING
//    '@' double-quote-character whitespace? new-line
//        expandable-here-string-characters? new-line double-quote-character '@'
//
//expandable-here-string-characters ::=
//    expandable-here-string-part+
//
//expandable-here-string-part ::=
//    !('$' | new-line)
////  | braced-variable
//  | '$' !( '('| new-line)
//  | '$' new-line !double-quote-character
//  | '$' new-line double-quote-character !'@'
//  | new-line !double-quote-character
//  | new-line double-quote-character !'@'

//expandable-string-with-subexpr-start:
//    double-quote-character  expandable-string-chars?  $(
//
//expandable-string-with-subexpr-end:
//    double-quote-char
//
//expandable-here-string-with-subexpr-start:
//    @  double-quote-character whitespace? new-line-character expandable-here-string-chars?  $(
//
//expandable-here-string-with-subexpr-end:
//    new-line-character  double-quote-character  @

verbatim-string-literal ::=
    VERBATIM_STRING
//    single-quote-character verbatim-string-characters? single-quote-char
//
//single-quote-character:
//    ' (U+0027)
//    Left single quotation mark (U+2018)
//    Right single quotation mark (U+2019)
//    Single low-9 quotation mark (U+201A)
//    Single high-reversed-9 quotation mark (U+201B)
//
//verbatim-string-characters:
//    verbatim-string-part
//    verbatim-string-characters verbatim-string-part
//
//verbatim-string-part:
//    *Any Unicode character except* single-quote-character
//    single-quote-character  single-quote-character

verbatim-here-string-literal ::=
    VERBATIM_MULTILINE_STRING
//    @ single-quote-character whitespace?  new-line-character
//        verbatim-here-string-characters?  new-line-character
//            single-quote-character *@*
//
//verbatim-*here-string-characters:
//    verbatim-here-string-part
//    verbatim-here-string-characters  verbatim-here-string-part
//
//verbatim-here-string-part:
//    Any Unicode character except* new-line-character
//    new-line-character  Any Unicode character except single-quote-character
//    new-line-character  single-quote-character  Any Unicode character except @

/* B.1.10 Simple Names */

private simple-name ::=
    SIMPLE_IDENTIFIER

/* B.1.11 Type Names */

type-name ::=
    type-identifier (DOT type-identifier)*

private type-identifier ::=
    SIMPLE_IDENTIFIER
//    TYPE_IDENTIFIER
//  | ATTRIBUTE_IDENTIFIER

array-type-name ::=
    type-name '['

generic-type-name ::=
    type-name '['

/** B.2 Syntactic grammar **/

/* B.2.1 Basic concepts */

private script-file ::=
    script-block

/*
module-file ::=
    script-block

interactive-input ::=
    script-block

data-file ::=
    statement-list
*/

/* B.2.2 Statements */

script-block ::=
    param-block? statement-terminator* script-block-body?

param-block ::=
    nl attribute-list? nl 'param' nl '(' parameter-list? nl ')'

private parameter-list ::=
    script-parameter (COMMA nl  script-parameter)*

script-parameter ::=
    nl attribute-list? nl variable script-parameter-default?

script-parameter-default ::=
    nl '=' nl expression

private script-block-body ::=
    named-block-list
  | statement-list

private named-block-list ::=
    named-block+

named-block ::=
    block-name statement-block statement-terminator*

block-name ::=
    'dynamicparam'
  | 'begin'
  | 'process'
  | 'end'

statement-block ::=
    nl '{' statement-list? nl '}'

private statement-list ::=
    statement+

private statement ::=
    if-statement
  | LABEL? labeled-statement
  | function-statement
  | flow-control-statement statement-terminator*
  | trap-statement
  | try-statement
  | data-statement
  | inline-script-statement
  | parallel-statement
  | sequence-statement
  | pipeline statement-terminator*

private statement-terminator ::=
    SEMICOLON
  | NEW_LINE

if-statement ::=
    'if' nl '(' nl pipeline nl ')' statement-block elseif-clauses? else-clause?

private elseif-clauses ::=
    elseif-clause+

elseif-clause ::=
    nl 'elseif' nl ( nl pipeline nl ) statement-block

else-clause ::=
    nl 'else' statement-block

private labeled-statement ::=
    switch-statement
  | foreach-statement
  | for-statement
  | while-statement
  | do-statement

switch-statement ::=
    'switch' nl switch-parameters? switch-condition switch-body

private switch-parameters ::=
    SWITCH_PARAMETER+

switch-condition ::=
    '(' nl pipeline nl ')'
   | '-file' nl switch-filename

switch-filename ::=
    command-argument
  | primary-expression

switch-body ::=
    nl '{' nl switch-clauses nl switch-default-clause? '}'

private switch-clauses ::=
    switch-clause+

switch-clause ::=
    switch-clause-condition statement-block statement-terminator*

switch-default-clause ::=
    'default' statement-block statement-terminator*

switch-clause-condition ::=
    command-argument
  | primary-expression

foreach-statement ::=
    'foreach' nl '(' nl variable nl 'in' nl pipeline nl ')' statement-block

for-statement ::=
    'for' nl '('
        nl for-initializer? statement-terminator+
        nl for-condition? statement-terminator+
        nl for-iterator?
        nl ')' statement-block
  | 'for' nl '('
        nl for-initializer? statement-terminator+
        nl for-condition?
        nl ')' statement-block
  | 'for' nl '('
        nl for-initializer?
        nl ')' statement-block

for-initializer ::=
    pipeline

for-condition ::=
    pipeline

for-iterator ::=
    pipeline

while-statement ::=
    'while' nl '(' nl while-condition nl ')' statement-block

do-statement ::=
    'do' statement-block nl ('while' | 'until') nl '(' while-condition nl ')'

while-condition ::=
    nl pipeline

function-statement ::=
    ('function'| 'filter'| 'workflow') nl function-name function-parameter-declaration? '{' script-block '}'

function-name ::=
    /* command-argument */
//    GENERIC_IDENTIFIER
    SIMPLE_IDENTIFIER

function-parameter-declaration ::=
    nl '(' parameter-list nl ')'

flow-control-statement ::=
    'break' label-expression?
  | 'continue' label-expression?
  | 'throw' pipeline?
  | 'return' pipeline?
  | 'exit' pipeline?

label-expression ::=
    simple-name
  | unary-expression

trap-statement ::=
    'trap' nl type-literal? nl statement-block

try-statement ::=
    'try' statement-block ((catch-clauses finally-clause) | (catch-clauses | finally-clause))

private catch-clauses ::=
    catch-clause+

catch-clause ::=
    nl 'catch' catch-type-list? statement-block

catch-type-list ::=
    nl type-literal (COMMA nl type-literal)*

finally-clause ::=
    nl 'finally' statement-block

data-statement ::=
    'data' nl data-name? data-commands-allowed? statement-block

data-name ::=
    simple-name

data-commands-allowed ::=
    nl SUPPORTED_COMMAND_PARAMETER data-commands-list

data-commands-list ::=
    nl data-command (COMMA nl data-command)*

data-command ::=
    command-name-expr

inline-script-statement ::=
    'inlinescript' statement-block

parallel-statement ::=
    'parallel' statement-block

sequence-statement ::=
    'sequence' statement-block

pipeline ::=
    assignment-expression
  | expression redirections? pipeline-tail?
  | command verbatim-command-argument? pipeline-tail?

assignment-expression ::=
    expression assignment-operator statement

private pipeline-tail ::=
    ('|' nl command)+

command ::=
    command-name command-element*
  | command-invocation-operator command-module? command-name-expr command-element*

command-invocation-operator ::=
    '&' | DOT

command-module ::=
    primary-expression

command-name ::=
    generic-token
  | generic-token-with-subexpr

generic-token-with-subexpr ::=
//    No whitespace is allowed between ) and command-name.
    generic-token-with-subexpr-start statement-list? ')' /*todo:no-space*/ command-name

private command-name-expr ::=
    command-name
  | primary-expression

private command-element ::=
    command-parameter
  | command-argument
  | redirections

command-argument ::=
    command-name-expr

private verbatim-command-argument ::=
    VERBATIM_COMMAND_ARGUMENT

private redirections ::=
    redirection+

redirection ::=
    merging-redirection-operator
  | file-redirection-operator redirected-file-name

redirected-file-name ::=
    command-argument
  | primary-expression

/* B.2.3 Expressions */

expression ::=
    logical-expression

logical-expression ::=
    bitwise-expression (logical-operator nl bitwise-expression)*

bitwise-expression ::=
    comparison-expression (bitwise-logical-operator nl comparison-expression)*

comparison-expression ::=
    additive-expression (comparison-operator nl additive-expression)*

additive-expression ::=
    multiplicative-expression (additive-operator nl multiplicative-expression)*

multiplicative-expression ::=
    format-expression (multiplicative-operator nl format-expression)*

format-expression ::=
    range-expression (format-operator nl range-expression)*

range-expression ::=
    array-literal-expression (range-operator nl array-literal-expression)*

array-literal-expression ::=
    unary-expression (array-literal-operator nl unary-expression)*

private unary-expression ::=
    primary-expression
  | expression-with-unary-operator

private expression-with-unary-operator ::=
    array-create-expression
  | pre-decrement-expression
  | logical-not-expression
  | bitwise-logical-not-expression
  | sign-expression
  | pre-increment-expression
  | cast-expression
  | split-expression
  | join-expression

array-create-expression ::=
    array-literal-operator nl unary-expression

split-expression ::=
    split-operator nl unary-expression

join-expression ::=
    join-operator nl unary-expression

sign-expression ::=
    additive-operator nl unary-expression

logical-not-expression ::=
    ('!' | logical-not-operator) nl unary-expression

bitwise-logical-not-expression ::=
    bitwise-logical-not-operator nl unary-expression

pre-increment-expression ::=
    increment-operator nl unary-expression

pre-decrement-expression ::=
    decrement-operator nl unary-expression

cast-expression ::=
    type-literal unary-expression

//attributed-expression ::=
//    type-literal variable

primary-expression ::=
    invocation-expression
  | element-access
  | member-access
  | post-increment-expression
  | post-decrement-expression
  | value

value ::=
    parenthesized-expression
  | sub-expression
  | array-expression
  | script-block-expression
  | hash-literal-expression
  | literal
  | type-literal
  | variable

private parenthesized-expression ::=
    '(' nl pipeline nl ')'

sub-expression ::=
    '$(' nl statement-list? nl ')'

array-expression ::=
    '@(' nl statement-list? nl ')'

script-block-expression ::=
    '{' nl script-block nl '}'

hash-literal-expression ::=
    '@{' nl hash-literal-body? nl '}'

hash-literal-body ::=
    hash-entry (statement-terminator+ hash-entry)*
/*
    hash-entry
    hash-literal-body statement-terminators hash-entry
*/

hash-entry ::=
    key-expression '=' nl statement

key-expression ::=
    simple-name
  | unary-expression

post-increment-expression ::=
    value increment-operator
  /* primary-expression ++ */

post-decrement-expression ::=
    value decrement-operator
  /* primary-expression dashdash */

member-access ::=
    /*todo:no-space*/ (DOT | '::') member-name primary-expression?
/*
 Note no whitespace is allowed after primary-expression.
    primary-expression . member-name
    primary-expression :: member-name
*/

element-access ::=
    /*todo:no-space*/ '[' nl expression nl ']' primary-expression?
/*
 Note no whitespace is allowed between primary-expression and [.
    primary-expression [ expression ]
*/

invocation-expression ::=
    /*todo:no-space*/ (DOT | '::') member-name argument-list primary-expression?
/*
 Note no whitespace is allowed after primary-expression.
   primary-expression . member-name argument-list
   primary-expression  :: member-name argument-list
*/

private argument-list ::=
    '(' argument-expression-list? nl ')'

private argument-expression-list ::=
    argument-expression (COMMA nl  argument-expression)*

argument-expression ::=
    logical-argument-expression

logical-argument-expression ::=
    nl bitwise-argument-expression (logical-operator bitwise-argument-expression)*

bitwise-argument-expression ::=
    comparison-argument-expression (bitwise-logical-operator nl comparison-argument-expression)*

comparison-argument-expression ::=
    additive-argument-expression (comparison-operator nl additive-argument-expression)*

additive-argument-expression ::=
    multiplicative-argument-expression (additive-operator nl multiplicative-argument-expression)*

multiplicative-argument-expression ::=
    format-argument-expression (multiplicative-operator nl format-argument-expression)*

format-argument-expression ::=
    range-argument-expression (format-operator nl range-argument-expression)*

range-argument-expression ::=
    unary-expression
  | range-expression range-operator nl unary-expression

member-name ::=
    simple-name
  | string-literal
//todo:  | string-literal-with-subexpression
  | expression-with-unary-operator
  | value

//string-literal-with-subexpression ::=
//    expandable-string-literal-with-subexpr
//    expandable-here-string-literal-with-subexpr
//
//expandable-string-literal-with-subexpr ::=
//    expandable-string-with-subexpr-start statement-list? )
//        expandable-string-with-subexpr-characters expandable-string-with-subexpr-end
//    expandable-here-string-with-subexpr-start statement-list? )
//        expandable-here-string-with-subexpr-characters
//        expandable-here-string-with-subexpr-end
//
//expandable-string-with-subexpr-characters ::=
//    expandable-string-with-subexpr-part
//    expandable-string-with-subexpr-characters expandable-string-with-subexpr-part
//
//expandable-string-with-subexpr-part ::=
//    sub-expression
//    expandable-string-part
//
//expandable-here-string-with-subexpr-characters ::=
//    expandable-here-string-with-subexpr-part
//    expandable-here-string-with-subexpr-characters expandable-here-string-with-subexpr-part
//
//expandable-here-string-with-subexpr-part ::=
//    sub-expression
//    expandable-here-string-part

type-literal ::=
    '[' type-spec ']'

private type-spec ::=
    array-type-name nl dimensions ']'
  | generic-type-name nl generic-type-arguments ']'
  | type-name

dimensions ::=
    COMMA*

generic-type-arguments ::=
    type-spec (COMMA nl  type-spec)*

/* B.2.4 Attributes */

attribute-list ::=
    attribute+

attribute ::=
    nl '[' nl attribute-name '(' attribute-arguments? nl ')' nl ']'
  | type-literal

attribute-name ::=
    type-spec

private attribute-arguments ::=
    attribute-argument+

attribute-argument ::=
    nl simple-name '=' nl expression
  | nl expression
  | nl simple-name