/**
* PowerShell grammar.
*
* @author Boris Pronin
* @see grammar reference: https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-15?view=powershell-7.3
*/

{
    parserClass="com.bopr.intellij.iipowershell.parser.PowerShellParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
//    psiClassPrefix="PowerShell"
    psiImplClassSuffix="Impl"
    psiPackage="com.bopr.intellij.iipowershell.psi"
    psiImplPackage="com.bopr.intellij.iipowershell.language.psi.impl"
    elementTypeHolderClass="com.bopr.intellij.iipowershell.language.psi.PowerShellTypes"
    elementTypeClass="com.bopr.intellij.iipowershell.language.psi.PowerShellElementType"
    tokenTypeClass="com.bopr.intellij.iipowershell.language.psi.PowerShellTokenType"

    tokens = [
//        NEW_LINE = 'regexp:[\u000D\u000A]|\u000D\u000A'
//        DASH = 'regexp:[-\u2013\u2014\u2015]'
//        SIMPLE_NAME = 'regexp:[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}_][\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nd}_]+'
//        DECIMAL_INTEGER = 'regexp:\d+(?i)[ld]?(kb|mb|gb|tb|pb)?'
//        HEXADECIMAL_INTEGER = 'regexp:0x(?i)[\da-f]+[ld]?(kb|mb|gb|tb|pb)?'
//        REAL = 
    ]
}

/* B.1 Lexical grammar */

input ::=
    input-element* signature-block?

private input-element ::=
    token
  | comment
  | whitespace

signature-block ::=
    '# SIG # Begin signature block' signature '# SIG # End signature block'

signature ::=
    'regexp:#.*'*

/* B.1.2 Comments */

comment ::=
    single-line-comment
  | requires-comment
  | delimited-comment

single-line-comment ::=
    'regexp:#.*'

delimited-comment ::=
    'regexp:<#+(?s).*#+>'

/* B.1.4 Tokens */

private token ::=
    keyword
  | variable
  | command
  | command-parameter  //interferes with negative number literals
  | command-argument-token
  | literal
  | type-literal
  | operator-or-punctuator

/* B.1.1 Line terminators */

private new-line-character ::=
//     'regexp:[\u000D\u000A]|\u000D\u000A'
     'regexp:[\r\n]|\r\n'

private new-lines ::=
    new-line-character*

/* B.1.3 White space */

private whitespace ::=
    'regexp:[\p{Zs}\p{Zl}\p{Zp}\u0009\u000B\u000C]'
  | '`' new-line-character

/* B.1.5 Keywords */

keyword ::=
    'begin'|'break'|'catch'|'class'|'continue'|'data'|'define'|'do'|'dynamicparam'|'else'|'elseif'|'end'|'exit'|
    'filter'|'finally'|'for'|'foreach'|'from'|'function'|'if'|'in'|'inlinescript'|'parallel'|'param'|'process'|
    'return'|'switch'|'throw'|'trap'|'try'|'until'|'using'|'var'|'while'|'workflow'

/* B.1.6 Variables */

variable ::=
    'regexp:\$\$|\$\?|\$\^|\$_'
  | 'regexp:[$@][\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nd}_?:]+'
  | 'regexp:\$\{[^}]+}'

/* B.1.9 Literals */

private literal ::=
    integer-literal
  | real-literal
  | string-literal

/* B.1.9.1 Integer Literals */

private sign ::=
    '+' | 'regexp:[-\u2013\u2014\u2015]'

integer-literal ::=
    sign? (decimal-integer-literal | hexadecimal-integer-literal)

decimal-integer-literal ::=
    'regexp:\d+(?i)[ld]?(kb|mb|gb|tb|pb)?'

hexadecimal-integer-literal ::=
    'regexp:0x(?i)[\da-f]+[ld]?(kb|mb|gb|tb|pb)?'

/* B.1.9.2 Real Literals */

real-literal ::=
    sign? ('regexp:(?i)(\d*\.\d+e?|\d+e)\d+[ld]?(kb|mb|gb|tb|pb)?')

/* B.1.9.3 String Literals */

string-literal ::=
    'regexp:["\u201C\u201D\u201E]([^$`"\u201C\u201D\u201E]|""|)*\$?["\u201C\u201D\u201E]'

/* B.1.12 Operators and punctuators */

private operator-or-punctuator ::=
    common-operator
  | assignment-operator
  | merging-redirection-operator
  | file-redirection-operator
  | comparison-operator
  | format-operator

common-operator ::=
    '{'|'@{'|'}'|'('|'$('|'@('|')'|'['|']'|'..'|'::'|'+'|'*'|'/'|'%'|'!'|'++'|'&'|'.'|','|'&&'|'||'|'|'|';'|
    'regexp:[-\u2013\u2014\u2015]'|
    'regexp:[-\u2013\u2014\u2015]{2}'|
    'regexp:[-\u2013\u2014\u2015](?i)(shl|shr)'|
    'regexp:[-\u2013\u2014\u2015](?i)b?(and|or|xor|not)'

assignment-operator ::=
    '='|'+='|'*='|'/='|'%='|'regexp:[-\u2013\u2014\u2015]='

file-redirection-operator ::=
    '>'|'>>'|'2>'|'2>>'|'3>'|'3>>'|'4>'|'4>>'|'5>'|'5>>'|'6>'|'6>>'|'*>'|'*>>'|'<'

merging-redirection-operator ::=
    '*>&1'|'2>&1'|'3>&1'|'4>&1'|'5>&1'|'6>&1'|'*>&2'|'1>&2'|'3>&2'|'4>&2'|'5>&2'|'6>&2'

comparison-operator ::=
    'regexp:[-\u2013\u2014\u2015](?i)(in|notin|isnot|is|as)' |
    'regexp:[-\u2013\u2014\u2015](?i)[ic]?(eq|ne|gt|lt|le|ge|match|notmatch|replace|like|notlike|contains|notcontains|split|join)'

format-operator ::=
    'regexp:[-\u2013\u2014\u2015](?i)f'

/* B.1.8 Parameters */

command-parameter ::=
    'regexp:[-\u2013\u2014\u2015]\w?[\w?]+'

/* B.1.11 Type Names */

type-name ::=
    type-identifier ('.' type-identifier)*

private type-identifier ::=
    type-characters

private type-characters ::=
    'regexp:[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nd}_]+'

array-type-name ::=
    type-name '['

generic-type-name ::=
    type-name '['

/* B.2.3 Expressions */

type-literal ::=
    '[' type-spec ']'

private type-spec ::=
    array-type-name new-lines? dimension* ']'
  | generic-type-name new-lines? generic-type-arguments ']'
  | type-name

private dimension ::=
    ','

private generic-type-arguments ::=
    type-spec new-lines? (',' new-lines? type-spec)*