/**
* PowerShell grammar.
*
* @see grammar reference: https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-15?view=powershell-7.3
*
* @author Boris Pronin
*/

{
    parserClass="com.bopr.intellij.iipowershell.parser.PowerShellParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiClassPrefix="PowerShell"
    psiImplClassSuffix="Impl"
    psiPackage="com.bopr.intellij.iipowershell.psi"
    psiImplPackage="com.bopr.intellij.iipowershell.language.psi.impl"
    elementTypeHolderClass="com.bopr.intellij.iipowershell.language.psi.PowerShellTypes"
    elementTypeClass="com.bopr.intellij.iipowershell.language.psi.PowerShellElementType"
    tokenTypeClass="com.bopr.intellij.iipowershell.language.psi.PowerShellTokenType"

   /* NOTE: In generated flex file change (.|\n) to ([^]|\n) */
    tokens = [
//        BLANK_SPACE = 'regexp:[\p{Zs}\p{Zl}\p{Zp}\u0009\u000B\u000C\n\r]+'
        BLANK_SPACE = 'regexp:\s+'
        SIGNATURE = 'regexp:# SIG # Begin signature block\n(#(.|\n)*)+# SIG # End signature block'
        REQUIRES_COMMENT = 'regexp:#\s*[rR]equires\s+.*'
        LINE_COMMENT = 'regexp:#.*'
        BLOCK_COMMENT = 'regexp:<#(.|\n)*#>'
        REAL_NUMBER = 'regexp:[+-\u2013\u2014\u2015]?\d*\.\d+([eE]\d+[lLdD]?(([kK]|[mM]|[gG]|[tT]|[pP])[bB])?)?'
        DECIMAL_INTEGER_NUMBER = 'regexp:[+\-\u2013\u2014\u2015]?\d+[lLdD]?(([kK]|[mM]|[gG]|[tT]|[pP])[bB])?'
        HEXADECIMAL_INTEGER_NUMBER = 'regexp:[+-\u2013\u2014\u2015]?0x[\da-fA-F]+[lLdD]?(([kK]|[mM]|[gG]|[tT]|[pP])[bB])?'
        KEYWORD = 'regexp:begin|break|catch|class|continue|data|define|do|dynamicparam|else|elseif|end|exit|filter|finally|for|foreach|from|function|if|in|inlinescript|parallel|param|process|return|switch|throw|trap|try|until|using|var|while|workflow'
        RESERVED_VARIABLE_NAME = 'regexp:\$\$|\$\?|\$\^|\$_'
        VARIABLE_NAME = 'regexp:[$@][\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nd}_?:]+'
//        TYPE_NAME = 'regexp:[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nd}_]+'
//        SIMPLE_NAME = 'regexp:[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}_][\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nd}_]+'
        BRACED_VARIABLE_NAME = 'regexp:\$\{[^}]+}'
        STRING = 'regexp:["\u201C\u201D\u201E]([^$`"\u201C\u201D\u201E]|"")*\$?["\u201C\u201D\u201E]'

        DOT = '.'
        COMMA = ','
        SEMICOLON = ';'
        BRACES = 'regexp:[{}]'
        BRACKETS = 'regexp:[\[\]]]'
        PARENTHESES = 'regexp:[()]'
//        DASH = 'regexp:[-\u2013\u2014\u2015]'
//        QUOTE = 'regexp:["\u201C\u201D\u201E]'
//        NUMBER_SIGN = 'regexp:[+\-\u2013\u2014\u2015]'
//        HEX_DIGITS='regexp:[\da-fA-F]'
//        INTEGER_NUMBER_SUFFIX = 'regexp:[lLdD]'
//        REAL_NUMBER_EXPONENT = 'regexp:[eE]\d+[lLdD]?(([kK]|[mM]|[gG]|[tT]|[pP])[bB])'
//        NUMBER_MULTIPLIER = 'regexp:([kK]|[mM]|[gG]|[tT]|[pP])[bB]'
//        STRING_CONTENT = 'regexp:([^$`"\u201C\u201D\u201E]|""|)*\$?'
    ]
}

/* B.1 Lexical grammar */

root ::=
    element* signature?

private element ::=
    token
  | comment
//  | whitespace

private signature ::=
    SIGNATURE

/* B.1.2 Comments */

private comment ::=
    single-line-comment
  | requires-comment
  | delimited-comment

private single-line-comment ::=
    LINE_COMMENT

private delimited-comment ::=
    BLOCK_COMMENT

private requires-comment ::=
    REQUIRES_COMMENT

/* B.1.4 Tokens */

private token ::=
    keyword
  | variable
//  | command
//  | command-parameter  //interferes with negative number literals
//  | command-argument-token
  | literal
//  | type-literal
//  | operator-or-punctuator

/* B.1.1 Line terminators */

//private new-line-character ::=
//     'regexp:[\r\n]|\r\n'
//
//private new-lines ::=
//    new-line-character*

/* B.1.3 White space */

//whitespace ::=
//    BLANK_SPACE
//  | '`' new-line-character

/* B.1.5 Keywords */

private keyword ::=
    KEYWORD

/* B.1.6 Variables */

variable ::=
    RESERVED_VARIABLE_NAME
  | VARIABLE_NAME
  | BRACED_VARIABLE_NAME

/* B.1.9 Literals */

private literal ::=
    integer-literal
  | real-literal
  | string-literal

/* B.1.9.1 Integer Literals */

private integer-literal ::=
    decimal-integer-literal | hexadecimal-integer-literal

private decimal-integer-literal ::=
    DECIMAL_INTEGER_NUMBER

private hexadecimal-integer-literal ::=
    HEXADECIMAL_INTEGER_NUMBER

/* B.1.9.2 Real Literals */

private real-literal ::=
    REAL_NUMBER

/* B.1.9.3 String Literals */

private string-literal ::=
    STRING

/* B.1.12 Operators and punctuators */

//private operator-or-punctuator ::=
//    common-operator
//  | assignment-operator
//  | merging-redirection-operator
//  | file-redirection-operator
//  | comparison-operator
//  | format-operator
//
//common-operator ::=
//    '{'|'@{'|'}'|'('|'$('|'@('|')'|'['|']'|'..'|'::'|'+'|'*'|'/'|'%'|'!'|'++'|'&'|'.'|','|'&&'|'||'|'|'|';'|
//    'regexp:[-\u2013\u2014\u2015]'|
//    'regexp:[-\u2013\u2014\u2015]{2}'|
//    'regexp:[-\u2013\u2014\u2015](?i)(shl|shr)'|
//    'regexp:[-\u2013\u2014\u2015](?i)b?(and|or|xor|not)'
//
//assignment-operator ::=
//    '='|'+='|'*='|'/='|'%='|'regexp:[-\u2013\u2014\u2015]='
//
//file-redirection-operator ::=
//    '>'|'>>'|'2>'|'2>>'|'3>'|'3>>'|'4>'|'4>>'|'5>'|'5>>'|'6>'|'6>>'|'*>'|'*>>'|'<'
//
//merging-redirection-operator ::=
//    '*>&1'|'2>&1'|'3>&1'|'4>&1'|'5>&1'|'6>&1'|'*>&2'|'1>&2'|'3>&2'|'4>&2'|'5>&2'|'6>&2'
//
//comparison-operator ::=
//    'regexp:[-\u2013\u2014\u2015](?i)(in|notin|isnot|is|as)' |
//    'regexp:[-\u2013\u2014\u2015](?i)[ic]?(eq|ne|gt|lt|le|ge|match|notmatch|replace|like|notlike|contains|notcontains|split|join)'
//
//format-operator ::=
//    'regexp:[-\u2013\u2014\u2015](?i)f'
//
///* B.1.8 Parameters */
//
//command-parameter ::=
//    'regexp:[-\u2013\u2014\u2015]\w?[\w?]+'
//
/* B.1.11 Type Names */
//
//private type-name ::=
//    type-identifier ('.' type-identifier)*
//
//private type-identifier ::=
//    type-characters
//
//private type-characters ::=
//    TYPE_NAME
//
//private array-type-name ::=
//    type-name '['
//
//private generic-type-name ::=
//    type-name '['
//
///* B.2.3 Expressions */
//
//type-literal ::=
//    '[' type-spec ']'
//
//private type-spec ::=
//    array-type-name new-lines? dimension* ']'
//  | generic-type-name new-lines? generic-type-arguments ']'
//  | type-name
//
//private dimension ::=
//    ','
//
//private generic-type-arguments ::=
//    type-spec new-lines? (',' new-lines? type-spec)*