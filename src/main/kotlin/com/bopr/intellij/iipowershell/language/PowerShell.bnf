/**
* PowerShell grammar.
*
* @see grammar reference: https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-15?view=powershell-7.3
*
* @author Boris Pronin
*/

{
    generate = [
        psi = 'no'
//        exact-types = 'elements'
//        java = '8'
    ]

    elementTypeClass="com.bopr.intellij.iipowershell.language.psi.PowerShellElementType"
    elementTypeHolderClass="com.bopr.intellij.iipowershell.language.psi.PowerShellTypes"
    extends="com.bopr.intellij.iipowershell.language.psi.PowerShellPsiElement"
    parserClass="com.bopr.intellij.iipowershell.parser.PowerShellParser"
//    psiClassPrefix="PowerShell"
    psiImplClassSuffix="Impl"
    psiImplPackage="com.bopr.intellij.iipowershell.language.psi.impl"
    psiImplUtilClass="com.bopr.intellij.iipowershell.language.psi.PowerShellPsiUtil"
    psiPackage="com.bopr.intellij.iipowershell.psi"
    tokenTypeClass="com.bopr.intellij.iipowershell.language.psi.PowerShellTokenType"

   /* NOTE: In generated flex file change (.|\n) to ([^]|\n) */
    tokens = [
        NEW_LINE = 'regexp:[\r\n]'
        WHITE_SPACE = 'regexp:\s+'
        LINE_COMMENT = 'regexp:#.*'
        REQUIRES_COMMENT = 'regexp:#\s*requires\s+.*'
        BLOCK_COMMENT = 'regexp:<#(.|\n)*#>'
        SIGNATURE = 'regexp:# SIG # Begin signature block\n(#(.|\n)*)+# SIG # End signature block'

        DECIMAL_INTEGER_NUMBER = 'regexp:[+-]?\d+[ld]?([kmgtp]b)?'
        HEXADECIMAL_INTEGER_NUMBER = 'regexp:[+-]?0x[0-9da-f]+[ld]?([kmgtp]b)?'
        REAL_NUMBER = 'regexp:[+-]?\d*\.\d+(e\d+[ld]?([kmgtp]b)?)?'
        STRING = 'regexp:"([^$`"]|"")*\$?"'

        KEYWORD = 'regexp:(begin|break|catch|class|continue|data|define|do|dynamicparam|elseif|else|end|exit|filter|finally|foreach|for|from|function|if|in|inlinescript|parallel|param|process|return|switch|throw|trap|try|until|using|var|while|workflow)'

        REGULAR_VARIABLE = 'regexp:[$@][\w_?:]+'
        BRACED_VARIABLE = 'regexp:\$\{[^}]+[^`]}'

        LABEL = 'regexp::\w+'

        ASSIGNMENT_OPERATOR = 'regexp:[+*/%-]?='
        FILE_REDIRECTION_OPERATOR = 'regexp:[><]|(>>)|(2>)|(2>>)|(3>)|(3>>)|(4>)|(4>>)|(5>)|(5>>)|(6>)|(6>>)|(\*>)|(\*>>)'
        MERGING_REDIRECTION_OPERATOR = 'regexp:(\*>&1)|(2>&1)|(3>&1)|(4>&1)|(5>&1)|(6>&1)|(\*>&2)|(1>&2)|(3>&2)|(4>&2)|(5>&2)|(6>&2)'
        FORMAT_OPERATOR = 'regexp:-f'
        COMPARISON_OPERATOR = 'regexp:-[ic]?(eq|ne|gt|lt|le|ge|match|notmatch|replace|like|notlike|contains|notcontains|split|join)'
        LOGICAL_OPERATOR = 'regexp:-and|or|xor'
        BITWISE_LOGICAL_OPERATOR = 'regexp:-band|bor|bxor'
        LOGICAL_NOT_OPERATOR = '-not'
        BITWISE_LOGICAL_NOT_OPERATOR = '-bnot'
        SPLIT_OPERATOR = '-split'
        JOIN_OPERATOR = '-join'
        
        VERBATIM_COMMAND_ARGUMENT = '--%.*'
//        MEMBER_ACCESS_OPERATOR = '.'
//        DIMENSION_OPERATOR = ','
        INCREMENT_OPERATOR = '++'
        DECREMENT_OPERATOR = '--'
        SYMBOLIC_OPERATOR = 'regexp:(\.\.)|(::)|(&&)|(\|\|)|[!&|,.\-+*/%]'

        FILE_PARAMETER = '-file'
        SUPPORTED_COMMAND_PARAMETER = '-supportedcommand'
        SWITCH_PARAMETER = 'regexp:-(regex|wildcard|exact|casesensitive|parallel)'
//        COMMAND_PARAMETER = 'regexp:-\w+[?\w]+;?'


//        TYPE_IDENTIFIER = 'regexp:[\p{Alpha}_]\w*'
        GENERIC_IDENTIFIER = "regexp:\w+[-?\w]+"
        SIMPLE_IDENTIFIER = 'regexp:[\p{Alpha}_]\w*'
        COMMAND_PARAMETER = 'regexp:[\p{Alpha}_?]\w*:?'
//        GENERIC_TOKEN_WITH_SUBEXPR_START = "regexp:\w+[-?\w]+\$\("
//        ARRAY_TYPE_NAME = 'regexp:\[\w+[-?\w]+]\['
//        GENERIC_TYPE_NAME = 'regexp:\[\w+[-?\w]+]\['

        DASH = '-'
        SEMICOLON = ';'
        DOUBLE_QUOTE = '"'

        /* Dummy items to generate corresponding tags */
        ATTRIBUTE_IDENTIFIER = '<attribute identifier>'
        TYPE_IDENTIFIER = '<type identifier>'
        BRACE = '<brace>'
        BRACKET = '<bracket>'
        PARENTHESIS = '<parenthesis>'
    ]
    
    name('.*expression') = 'expression'
    name('.*statement') = 'statement'
    name('.*operator') = 'operator'
}

root ::=
//  "regexp:.*"
    script-file
//  | module-file
//  | interactive-input
//  | data-file

private no-space ::=
    "" //todo:

private comparison-operator ::=
    COMPARISON_OPERATOR

private format-operator ::=
    FORMAT_OPERATOR

private assignment-operator ::=
    ASSIGNMENT_OPERATOR

private file-redirection-operator ::=
    FILE_REDIRECTION_OPERATOR

private merging-redirection-operator ::=
    MERGING_REDIRECTION_OPERATOR

private increment-operator ::=
    INCREMENT_OPERATOR

private decrement-operator ::=
    DECREMENT_OPERATOR

private additive-operator ::=
    '+' | DASH

private multiplicative-operator ::=
    '\*' | '/' | '%'

private logical-operator ::=
    LOGICAL_OPERATOR

private bitwise-logical-operator ::=
    BITWISE_LOGICAL_OPERATOR

private logical-not-operator ::=
    LOGICAL_NOT_OPERATOR

private bitwise-logical-not-operator ::=
    BITWISE_LOGICAL_NOT_OPERATOR

private split-operator ::=
    SPLIT_OPERATOR

private join-operator ::=
    JOIN_OPERATOR

private range-operator ::=
    '..'

private array-literal-operator ::=
    ','

private variable ::=
    REGULAR_VARIABLE
  | braced-variable

private braced-variable ::=
    BRACED_VARIABLE
//  | escaped-character

//escaped-character ::=
//    '`'   //(The backtick character U+0060) followed by any Unicode character

/* B.1.7 Commands */

generic-token ::=
    generic-token-parts

private generic-token-parts ::=
    generic-token-part+

private generic-token-part ::=
    expandable-string-literal
  | verbatim-here-string-literal
  | variable
  | generic-token-char

private generic-token-char ::=
    GENERIC_IDENTIFIER
/*
    Any Unicode character except
        {   }   (   )   ;   ,   |   &   $
        ` (The backtick character U+0060)
        double-quote-character
        single-quote-character
        whitespace
        new-line-character
        escaped-character
*/

generic-token-with-subexpr-start ::=
    generic-token-parts '$('

/* B.1.8 Parameters*/

private command-parameter ::=
//    dash first-parameter-char parameter-chars colon~opt~
    COMMAND_PARAMETER

/*
first-parameter-char:
    A Unicode character of classes Lu, Ll, Lt, Lm, or Lo
    _ (The underscore character U+005F)
    ?
parameter-char:
    Any Unicode character except
        { } ( ) ; , | & . [
        colon
        whitespace
        new-line-character
colon:
    : (The colon character U+003A)
*/


//verbatim-command-argument-chars ::=
//     verbatim-command-argument-part+
//
//verbatim-command-argument-part ::=
//     verbatim-command-string
//     | '&' non-ampersand-character
//     | non-vert-line-character
//
//non-ampersand-character ::=
//    !'&'
//
//non-vert-line-character ::=
//    !'|'
//
//verbatim-command-string ::=
//     double-quote-character non-double-quote-chars
//   | double-quote-character
//
//non-double-quote-chars ::=
////todo: DOES NOT WORK
//    (!double-quote-character)+

/* B.1.9 Literals */

private literal ::=
    integer-literal
  | real-literal
  | string-literal

/* B.1.9.1 Integer Literals */

integer-literal ::=
    DECIMAL_INTEGER_NUMBER | HEXADECIMAL_INTEGER_NUMBER

/* B.1.9.2 Real Literals */

real-literal ::=
    REAL_NUMBER

/* B.1.9.3 String Literals */

string-literal ::=
    expandable-string-literal
  | expandable-here-string-literal
  | verbatim-string-literal
  | verbatim-here-string-literal

expandable-string-literal ::=
    STRING
//    DOUBLE_QUOTE expandable-string-characters? '$'* DOUBLE_QUOTE

expandable-string-characters ::=
    expandable-string-part+

expandable-string-part ::=
    !('$' | DOUBLE_QUOTE | '`')
  | braced-variable
//  | '$' !('(' |'{' | DOUBLE_QUOTE | '`')
//  | '$' escaped-character
//  | escaped-character
//  | DOUBLE_QUOTE DOUBLE_QUOTE

/*
    Any Unicode character except
        $
        double-quote-character
        ` (The backtick character U+0060)
    braced-variable
    $ Any Unicode character except
        (
        {
        double-quote-character
        ` (The backtick character U+0060)*
    $ escaped-character
    escaped-character
    double-quote-character double-quote-character
*/

expandable-here-string-literal ::=
    MULTILINE_STRING
//    '@' double-quote-character whitespace? new-line
//        expandable-here-string-characters? new-line double-quote-character '@'
//
//expandable-here-string-characters ::=
//    expandable-here-string-part+
//
//expandable-here-string-part ::=
//    !('$' | new-line)
////  | braced-variable
//  | '$' !( '('| new-line)
//  | '$' new-line !double-quote-character
//  | '$' new-line double-quote-character !'@'
//  | new-line !double-quote-character
//  | new-line double-quote-character !'@'

//expandable-string-with-subexpr-start:
//    double-quote-character  expandable-string-chars?  $(
//
//expandable-string-with-subexpr-end:
//    double-quote-char
//
//expandable-here-string-with-subexpr-start:
//    @  double-quote-character whitespace? new-line-character expandable-here-string-chars?  $(
//
//expandable-here-string-with-subexpr-end:
//    new-line-character  double-quote-character  @

verbatim-string-literal ::=
    VERBATIM_STRING
//    single-quote-character verbatim-string-characters? single-quote-char
//
//single-quote-character:
//    ' (U+0027)
//    Left single quotation mark (U+2018)
//    Right single quotation mark (U+2019)
//    Single low-9 quotation mark (U+201A)
//    Single high-reversed-9 quotation mark (U+201B)
//
//verbatim-string-characters:
//    verbatim-string-part
//    verbatim-string-characters verbatim-string-part
//
//verbatim-string-part:
//    *Any Unicode character except* single-quote-character
//    single-quote-character  single-quote-character

verbatim-here-string-literal ::=
    VERBATIM_MULTILINE_STRING
//    @ single-quote-character whitespace?  new-line-character
//        verbatim-here-string-characters?  new-line-character
//            single-quote-character *@*
//
//verbatim-*here-string-characters:
//    verbatim-here-string-part
//    verbatim-here-string-characters  verbatim-here-string-part
//
//verbatim-here-string-part:
//    Any Unicode character except* new-line-character
//    new-line-character  Any Unicode character except single-quote-character
//    new-line-character  single-quote-character  Any Unicode character except @

/* B.1.10 Simple Names */

private simple-name ::=
    SIMPLE_IDENTIFIER

/* B.1.11 Type Names */

type-name ::=
    type-identifier ('.' type-identifier)*

private type-identifier ::=
    TYPE_IDENTIFIER
  | ATTRIBUTE_IDENTIFIER

array-type-name ::=
    type-name '['

generic-type-name ::=
    type-name '['

/** B.2 Syntactic grammar **/

/* B.2.1 Basic concepts */

private script-file ::=
    script-block

/*
module-file ::=
    script-block

interactive-input ::=
    script-block

data-file ::=
    statement-list
*/

/* B.2.2 Statements */

script-block ::=
    param-block? statement-terminators? script-block-body?

param-block ::=
    attribute-list? 'param' '(' parameter-list? ')'

private parameter-list ::=
    script-parameter (',' script-parameter)*

script-parameter ::=
    attribute-list? variable script-parameter-default?

script-parameter-default ::=
    '=' expression

private script-block-body ::=
    named-block-list
  | statement-list

private named-block-list ::=
    named-block+

named-block ::=
    block-name statement-block statement-terminators?

block-name ::=
    'dynamicparam' | 'begin' | 'process' | 'end'

statement-block ::=
    '{' statement-list? '}'

private statement-list ::=
    statement+

private statement ::=
    if-statement
  | LABEL? labeled-statement
  | function-statement
  | flow-control-statement statement-terminator?
  | trap-statement
  | try-statement
  | data-statement
  | inline-script-statement
  | parallel-statement
  | sequence-statement
  | pipeline statement-terminator?

private statement-terminator ::=
    SEMICOLON
//  | NEW_LINE
//  | <<eof>>

private statement-terminators ::=
    statement-terminator+

if-statement ::=
    'if' '(' pipeline ')' statement-block elseif-clauses? else-clause?

private elseif-clauses ::=
    elseif-clause+

elseif-clause ::=
    'elseif' ( pipeline ) statement-block

else-clause ::=
    'else' statement-block

private labeled-statement ::=
    switch-statement
  | foreach-statement
  | for-statement
  | while-statement
  | do-statement

switch-statement ::=
    'switch' switch-parameters? switch-condition switch-body

private switch-parameters ::=
    SWITCH_PARAMETER+

switch-condition ::=
    '(' pipeline ')'
   | FILE_PARAMETER switch-filename

switch-filename ::=
    command-argument
  | primary-expression

switch-body ::=
    '{' switch-clauses switch-default-clause? '}'

private switch-clauses ::=
    switch-clause+

switch-clause ::=
    switch-clause-condition statement-block statement-terminators?

switch-default-clause ::=
    'default' statement-block statement-terminators?

switch-clause-condition ::=
    command-argument
  | primary-expression

foreach-statement ::=
    'foreach' '(' variable 'in' pipeline ')' statement-block

for-statement ::=
    'for' '(' for-initializer? statement-terminator
        for-condition? statement-terminator for-iterator? ')' statement-block
  | 'for' '(' for-initializer? statement-terminator
        for-condition? ')' statement-block
  | 'for' '(' for-initializer? ')' statement-block

for-initializer ::=
    pipeline

for-condition ::=
    pipeline

for-iterator ::=
    pipeline

while-statement ::=
    'while' '(' while-condition ')' statement-block

do-statement ::=
    'do' statement-block ('while' | 'until') '(' while-condition ')'

while-condition ::=
    pipeline

function-statement ::=
    ('function'| 'filter'| 'workflow') function-name function-parameter-declaration? '{' script-block '}'

function-name ::=
    /* command-argument */
    GENERIC_IDENTIFIER
    
function-parameter-declaration ::=
    '(' parameter-list ')'

flow-control-statement ::=
    'break' label-expression?
  | 'continue' label-expression?
  | 'throw' pipeline?
  | 'return' pipeline?
  | 'exit' pipeline?

label-expression ::=
    simple-name
  | unary-expression

trap-statement ::=
    'trap' type-literal? statement-block

try-statement ::=
    'try' statement-block ((catch-clauses finally-clause) | (catch-clauses | finally-clause))

private catch-clauses ::=
    catch-clause+

catch-clause ::=
    'catch' catch-type-list? statement-block

catch-type-list ::=
    type-literal (',' type-literal)*

finally-clause ::=
    'finally' statement-block

data-statement ::=
    'data' data-name? data-commands-allowed? statement-block

data-name ::=
    simple-name

data-commands-allowed ::=
    SUPPORTED_COMMAND_PARAMETER data-commands-list

data-commands-list ::=
    data-command (',' data-command)*

data-command ::=
    command-name-expr

inline-script-statement ::=
    'inlinescript' statement-block

parallel-statement ::=
    'parallel' statement-block

sequence-statement ::=
    'sequence' statement-block

pipeline ::=
    assignment-expression
  | expression redirections? pipeline-tail?
  | command verbatim-command-argument? pipeline-tail?

assignment-expression ::=
    expression assignment-operator statement

private pipeline-tail ::=
    ('|' command)+

command ::=
    command-name command-element*
  | command-invocation-operator command-module? command-name-expr command-element*

command-invocation-operator ::=
    '&' | '.'

command-module ::=
    primary-expression

command-name ::=
    generic-token
  | generic-token-with-subexpr

generic-token-with-subexpr ::=
//    No whitespace is allowed between ) and command-name.
    generic-token-with-subexpr-start statement-list? ')' /*todo:no-space*/ command-name

private command-name-expr ::=
    command-name
  | primary-expression

private command-element ::=
    command-parameter
  | command-argument
  | redirections

command-argument ::=
    command-name-expr

private verbatim-command-argument ::=
    VERBATIM_COMMAND_ARGUMENT

private redirections ::=
    redirection+

redirection ::=
    merging-redirection-operator
  | file-redirection-operator redirected-file-name

redirected-file-name ::=
    command-argument
  | primary-expression

/* B.2.3 Expressions */

expression ::=
    logical-expression

logical-expression ::=
    bitwise-expression (logical-operator bitwise-expression)*

bitwise-expression ::=
    comparison-expression (bitwise-logical-operator comparison-expression)*

comparison-expression ::=
    additive-expression (comparison-operator additive-expression)*

additive-expression ::=
    multiplicative-expression (additive-operator multiplicative-expression)*

multiplicative-expression ::=
    format-expression (multiplicative-operator format-expression)*

format-expression ::=
    range-expression (format-operator range-expression)*

range-expression ::=
    array-literal-expression (range-operator array-literal-expression)*

array-literal-expression ::=
    unary-expression (array-literal-operator unary-expression)*

private unary-expression ::=
    primary-expression
  | expression-with-unary-operator

private expression-with-unary-operator ::=
    array-create-expression
  | pre-decrement-expression
  | logical-not-expression
  | bitwise-logical-not-expression
  | sign-expression
  | pre-increment-expression
  | cast-expression
  | split-expression
  | join-expression

array-create-expression ::=
    array-literal-operator unary-expression

split-expression ::=
    split-operator unary-expression

join-expression ::=
    join-operator unary-expression

sign-expression ::=
    additive-operator unary-expression

logical-not-expression ::=
    ('!' | logical-not-operator) unary-expression

bitwise-logical-not-expression ::=
    bitwise-logical-not-operator unary-expression

pre-increment-expression ::=
    increment-operator unary-expression

pre-decrement-expression ::=
    decrement-operator unary-expression

cast-expression ::=
    type-literal unary-expression

//attributed-expression ::=
//    type-literal variable

primary-expression ::=
    invocation-expression
  | element-access
  | member-access
  | post-increment-expression
  | post-decrement-expression
  | value

value ::=
    parenthesized-expression
  | sub-expression
  | array-expression
  | script-block-expression
  | hash-literal-expression
  | literal
  | type-literal
  | variable

private parenthesized-expression ::=
    '(' pipeline ')'

sub-expression ::=
    '$(' statement-list? ')'

array-expression ::=
    '@(' statement-list? ')'

script-block-expression ::=
    '{' script-block '}'

hash-literal-expression ::=
    '@{' hash-literal-body? '}'

hash-literal-body ::=
    hash-entry (statement-terminators hash-entry)*

hash-entry ::=
    key-expression '=' statement

key-expression ::=
    simple-name
  | unary-expression

post-increment-expression ::=
//    primary-expression increment-operator
    value increment-operator

post-decrement-expression ::=
//    primary-expression decrement-operator
    value decrement-operator

member-access ::=
// Note no whitespace is allowed after primary-expression.
//    primary-expression '.' member-name
//  | primary-expression '::' member-name
    /*todo:no-space*/ ('.' | '::') member-name primary-expression?

element-access ::=
// Note no whitespace is allowed between primary-expression and [.
//    primary-expression '[' expression ']'
    /*todo:no-space*/ '[' expression ']' primary-expression?

invocation-expression ::=
// Note no whitespace is allowed after primary-expression.
//   primary-expression '.' member-name argument-list
//   | primary-expression  '::' member-name argument-list
//    ('.' | '::') member-name argument-list primary-expression?
    /*todo:no-space*/ ('.' | '::') member-name argument-list primary-expression?

private argument-list ::=
    '(' argument-expression-list? ')'

private argument-expression-list ::=
    argument-expression (',' argument-expression)*

argument-expression ::=
    logical-argument-expression

logical-argument-expression ::=
    bitwise-argument-expression (logical-operator bitwise-argument-expression)*

bitwise-argument-expression ::=
    comparison-argument-expression (bitwise-logical-operator comparison-argument-expression)*

comparison-argument-expression ::=
    additive-argument-expression (comparison-operator additive-argument-expression)*

additive-argument-expression ::=
    multiplicative-argument-expression (additive-operator multiplicative-argument-expression)*

multiplicative-argument-expression ::=
    format-argument-expression (multiplicative-operator format-argument-expression)*

format-argument-expression ::=
    range-argument-expression (format-operator range-argument-expression)*

range-argument-expression ::=
    unary-expression
  | range-expression range-operator unary-expression

member-name ::=
    simple-name
  | string-literal
//  | string-literal-with-subexpression
  | expression-with-unary-operator
  | value

//string-literal-with-subexpression ::=
//    expandable-string-literal-with-subexpr
//    expandable-here-string-literal-with-subexpr
//
//expandable-string-literal-with-subexpr ::=
//    expandable-string-with-subexpr-start statement-list? )
//        expandable-string-with-subexpr-characters expandable-string-with-subexpr-end
//    expandable-here-string-with-subexpr-start statement-list? )
//        expandable-here-string-with-subexpr-characters
//        expandable-here-string-with-subexpr-end
//
//expandable-string-with-subexpr-characters ::=
//    expandable-string-with-subexpr-part
//    expandable-string-with-subexpr-characters expandable-string-with-subexpr-part
//
//expandable-string-with-subexpr-part ::=
//    sub-expression
//    expandable-string-part
//
//expandable-here-string-with-subexpr-characters ::=
//    expandable-here-string-with-subexpr-part
//    expandable-here-string-with-subexpr-characters expandable-here-string-with-subexpr-part
//
//expandable-here-string-with-subexpr-part ::=
//    sub-expression
//    expandable-here-string-part

type-literal ::=
    '[' type-spec ']'

private type-spec ::=
    array-type-name dimensions ']'
  | generic-type-name generic-type-arguments ']'
  | type-name

dimensions ::=
    ','*

generic-type-arguments ::=
    type-spec (',' type-spec)*

/* B.2.4 Attributes */

attribute-list ::=
    attribute+

attribute ::=
    '[' attribute-name '(' attribute-arguments? ')' ']'
  | type-literal

attribute-name ::=
    type-spec

private attribute-arguments ::=
    attribute-argument+

attribute-argument ::=
    simple-name '=' expression
  | expression
  | simple-name